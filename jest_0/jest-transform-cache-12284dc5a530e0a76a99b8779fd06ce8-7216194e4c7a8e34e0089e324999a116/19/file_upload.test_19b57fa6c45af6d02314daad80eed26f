'use strict';var _actions = require('../../src/actions');





var _reduxMockStore = require('redux-mock-store');var _reduxMockStore2 = _interopRequireDefault(_reduxMockStore);
var _reduxThunk = require('redux-thunk');var _reduxThunk2 = _interopRequireDefault(_reduxThunk);
var _fetchMock = require('fetch-mock');var _fetchMock2 = _interopRequireDefault(_fetchMock);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

var middlewares = [_reduxThunk2.default];
var mockStore = (0, _reduxMockStore2.default)(middlewares);

describe('actions/fileDropped', function () {
    it('returns dropped document', function () {
        expect(
        (0, _actions.fileDropped)({ body: "test" })).
        toEqual({
            type: _actions.FILE_DROP,
            document: { body: "test" } });

    });
});

describe('actions/fileStartUpload', function () {
    it('returns FILE_START_UPLOAD', function () {
        expect(
        (0, _actions.fileStartUpload)("test")).
        toEqual({
            type: _actions.FILE_START_UPLOAD });

    });
});

describe('actions/storeDocuments', function () {
    var store = void 0,myMock = void 0;

    beforeEach(function () {
        var now = Date.now();
        Date.now = jest.genMockFunction().mockReturnValue(now);

        store = mockStore({});
    });

    afterEach(function () {
        myMock.restore();
    });

    it('stores given document and returns file information', function () {
        var mockResult = [
        { fileName: "foo.pdf" }];

        myMock = _fetchMock2.default.post('/ajax/document', mockResult);

        var files = ['foo'];
        var tags = [{ key: 1, label: 't1' }, { key: 2, label: 't2' }];

        var formData = new FormData();
        formData.append('files[]', 'foo');
        formData.append('tags[1]', 't1');
        formData.append('tags[2]', 't2');
        formData.append('action', 'upload');

        return store.dispatch((0, _actions.storeDocuments)(files, tags)).
        then(function () {
            expect(myMock.called('/ajax/document')).toBe(true);
            var options = myMock.lastOptions('/ajax/document');

            expect(options).toHaveProperty('method');
            expect(options.method).toBe("POST");
            expect(options).toHaveProperty('body');
            expect(options.body.get('files[]')).toEqual('foo');
            expect(options.body.get('tags[1]')).toEqual('t1');
            expect(options.body.get('tags[2]')).toEqual('t2');
            expect(options.body.get('action')).toEqual('upload');

            var expectedActions = store.getActions();
            expect(expectedActions.length).toBe(2);
            expect(expectedActions).toContainEqual({
                type: _actions.FILE_START_UPLOAD });

            expect(expectedActions).toContainEqual({
                type: _actions.DOCUMENTS_STORED,
                documents: mockResult,
                receivedAt: Date.now() });

        });
    });


    it('returns an invalid response', function () {
        myMock = _fetchMock2.default.post('/ajax/document', 401);

        return store.dispatch((0, _actions.storeDocuments)([], [])).
        then(function () {
            expect(myMock.called('/ajax/document')).toBe(true);

            var expectedActions = store.getActions();
            expect(expectedActions.length).toBe(2);
            expect(expectedActions).toContainEqual({
                type: _actions.FILE_START_UPLOAD });

            expect(expectedActions).toContainEqual({
                type: _actions.DOCUMENTS_NOT_STORED,
                documents: [],
                receivedAt: Date.now() });

        });
    });

    it('returns DOCUMENTS_NOT_STORED if ajax response is not valid json', function () {
        myMock = _fetchMock2.default.post('/ajax/document', "invalid json");

        return store.dispatch((0, _actions.storeDocuments)([], [])).
        then(function () {
            expect(myMock.called('/ajax/document')).toBe(true);

            var expectedActions = store.getActions();
            expect(expectedActions).toContainEqual({
                type: _actions.DOCUMENTS_NOT_STORED,
                documents: [],
                receivedAt: Date.now() });

        });
    });
});